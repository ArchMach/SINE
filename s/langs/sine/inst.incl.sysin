

          extrn     $real_make_screen,$real_display,$real_force_display
          extrn     $real_print,scs$cl,scs$ioars_nnl,$real_display_screen
          extrn     $real_get_hpos
          entry     make_variable,make_mark,set_mark_reg,eval_mark_reg
          entry     tyi

*         This is the code for all the instructions sine knows about

     instruction    add
          l    rv,op1(ops)
          a    rv,op2(ops)
          br   link

     instruction    sub
          l    rv,op1(ops)
          s    rv,op2(ops)
          br   link

     instruction    mul
          l    9,op1(ops)
          m    8,op2(ops)
          lr   rv,9
          br   link

     instruction    div
          lis  8,0
          l    9,op1(ops)
          bnms div.ok
          lcs  8,1
div.ok    d    8,op2(ops)
          lr   rv,9
          br   link

     instruction    mod
          lis  8,0
          l    9,op1(ops)
          bnms mod.ok
          lcs  8,1
mod.ok    d    8,op2(ops)
          lr   rv,8
          br   link

     instruction    and
          l    rv,op1(ops)
          n    rv,op2(ops)
          br   link

     instruction    or
          l    rv,op1(ops)
          o    rv,op2(ops)
          br   link

     instruction    xor
          l    rv,op1(ops)
          x    rv,op2(ops)
          br   link

     instruction    min
          l    rv,op1(ops)
          c    rv,op2(ops)
          bnpr link
          l    rv,op2(ops)
          br   link

     instruction    max
          l    rv,op1(ops)
          c    rv,op2(ops)
          bnmr link
          l    rv,op2(ops)
          br   link

     instruction    car
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          br   link

     instruction    cdr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          br   link

     instruction    caar
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          l    rv,cons.car(rv)
          br   link

     instruction    cadr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          l    rv,cons.car(rv)
          br   link

     instruction    cdar
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          l    rv,cons.cdr(rv)
          br   link

     instruction    cddr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          l    rv,cons.cdr(rv)
          br   link

     instruction    cons
          lis  5,8                           a cons is 8 bytes long
          save
          bal  link,allocate
          restore
          l    t2,op1(ops)
          st   t2,cons.car(rv)
          l    t2,op2(ops)
          st   t2,cons.cdr(rv)
          oi   rv,cons_bits
          br   link

     instruction    rplaca
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   t2,cons.car(rv)
          br   link

     instruction    rplacd
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   t2,cons.cdr(rv)
          br   link

init_routine   equ  t2

     instruction    rsearch
          la   init_routine,getr_init
          lr   t3,link                       we can bash about anything here
          bal  link,s.common
          ais  rv,1
          br   t3

     instruction    search
          la   init_routine,get_init
s.common  save
          lis  temp,0
          st   temp,error_register
          l    source,op2(ops)               string to search for
          la   temp,getr_init
          clr  temp,init_routine
          bnes s.not_rev
          bal  link,get_length               start at the end if in reverse
          lr   index,rv                      start at beginning
          sis  index,1
          bs   s.init
s.not_rev lis  index,0
s.init    st   index,segptr(sp)

          l    source,op1(ops)               get string to search though
          l    index,buffer.location(source)
          balr link,init_routine
s.restart save_sv   haystack
          l    source,op2(ops)
          l    index,segptr(sp)
          balr link,init_routine
          balr link,get
          b    s.found                       empty SS
          lr   type,char                     first find first char of SS
          save_sv   needle
          load_sv   haystack
s.look    balr link,get
          b    s.failed
error12   equ  *                             search failed
          clr  type,char
          bnes s.look

          lr   t1,index                      save for failing search
s.compare save_sv   haystack
          load_sv   needle
          balr link,get                      get next char in needle to check
          b    s.found
          lr   rv,char
          save_sv   needle
          load_sv   haystack
          balr link,get
          b    s.failed
          clr  rv,char
          be   s.compare
          lr   index,t1                      keep looking
          b    s.restart

s.found   equ  *
          l    rv,search_save_area_haystack+8     index(haystack)
          l    source,search_save_area_haystack   source(haystack)
          make_virtual_bufptr rv,source
          b    get_no_error

s.failed  lis  rv,0
          b    get_error

s.recover clhi t1,get_init                        doing search or rsearch?
          be   s.return_end
          lis  rv,0
          b    popj

s.return_end   equ  *
          l    source,op1(ops)
          bal  link,get_length
          b    popj

     instruction    searchr
          lr   t1,link
          bal  link,search
sr.common l    source,op1(ops)
          s    rv,buffer.location(source)
          br   t1

     instruction    rsearchr
          lr   t1,link
          bal  link,rsearch
          bs   sr.common

*         call iocs$get_chars (user_input,addr(buffer),num_chars,num_read,code);

     instruction    tyi
          stm  temp,register_save(sp)   incase of break!!!!
          lhi  temp,-2                  amount to backup if break hit
          sth  temp,break_enabled

          la   temp,user_input
          st   temp,arg1p(sp)
          la   temp,segptr(sp)          don't use io_buffer since we are called
          st   temp,segsize(sp)         by print which has stuff there
          la   temp,segsize(sp)
          st   temp,arg2p(sp)
          la   temp,a_one
          st   temp,arg3p(sp)
          la   temp,code
          st   temp,arg4p(sp)
          la   temp,code
          st   temp,arg5p(sp)
          lhi  temp,24
          st   temp,alist_size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$get_chars
          lis  temp,0
          sth  temp,break_enabled
          restore

          lb   rv,segptr(sp)       get the char
          br   link

*         call iocs$put_chars (user_output, addr(io_buffer), num_chars, code);

     instruction    tyo
          l    t1,op1(ops)              get char to print
          stb  t1,io_buffer(sp)

          la   temp,user_output
          st   temp,arg1p(sp)
          la   temp,io_buffer_ptr(sp)
          st   temp,arg2p(sp)
          la   temp,a_one
          st   temp,arg3p(sp)
          la   temp,code
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist_size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$put_chars
          restore
          lr   rv,t1
          br   link

a_one     dac  1

*         Prints a text object

     instruction    print
          lis  rv,0                no clear to end of line
          b    $real_print

     instruction    print_clearing
          lis  rv,1
          b    $real_print

*         returns the number of characters in the input buffer

     instruction    tyis
          la   temp,user_input
          st   temp,arg1p(sp)
          la   temp,status_string
          st   temp,arg2p(sp)
          la   temp,io_buffer(sp)
          st   temp,io_buffer_ptr(sp)
          la   temp,io_buffer_ptr(sp)   returns input and output status in
          st   temp,arg3p(sp)           successive HWs.
          la   temp,code
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist_size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$order
          restore
          lh   rv,io_buffer(sp)
          br   link

status_string  equ  *
          dc   c'status  '

*         descriptor hacking

     instruction    cline
          save
          l    source,op1(ops)
          bal  link,get_length
          sth  rv,dscrs+2               build up pl/1 type descriptors
          lhi  rv,x'1400'
          sth  rv,dscrs
          lis  index,0
          bal  link,get_init
          la   t1,io_buffer(sp)
cline.loop     equ  *
          balr link,get
          b    cline.sendit
          stb  char,0(t1)
          ais  t1,1
          bs   cline.loop

cline.sendit   equ  *
          la   temp,io_buffer(sp)
          st   temp,arg1p(sp)
          lcs  temp,8                   negative => descriptors
          st   temp,alist_size(sp)
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$cl
          b    popj

     instruction    call_af
          save
          lis  temp,0
          st   temp,error_register
          la   t1,3*56(stack)
          st   t1,arg1p(sp)
          li   temp,c'sine'
          st   temp,0(t1)
          li   temp,c'_mac'
          st   temp,4(t1)
          li   temp,c'hine'
          st   temp,8(t1)
          li   temp,c'$haf'
          st   temp,12(t1)
          lhi  temp,c' ['
          sth  temp,16(t1)
          l    source,op1(ops)
          la   t1,18(t1)
          lis  index,0
          bal  link,get_init
caf.get_loop   equ  *
          balr link,get
          bs   caf.do_call                   remember skip return
          dc   0
          stb  char,0(t1)
          ais  t1,1
          bs   caf.get_loop

caf.do_call    equ  *
          lhi  temp,c']'
          stb  temp,0(t1)
          shi  t1,3*56-1(stack)              get number of chars.
          sth  t1,dscrs+6
          lhi  temp,x'1400'
          sth  temp,dscrs+4

          la   temp,code(ls)
          st   temp,arg2p(sp)
          li   temp,x'1100001f'         fixed bin(31)
          st   temp,dscrs
          lcs  temp,12
          st   temp,alist_size(sp)

          save
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$cl
          restore

          lhi  rv,32                    if error return " "
          l    temp,code(ls)
          bm   get_error
          l    rv,get.stop(ls)
get_no_error   equ  *
          lis  temp,0
          st   temp,error_register
          b    popj

          entry     get_code_ptr
get_code_ptr   equ  *
          .ent 0
          la   temp,get.stop(ls)
          l    5,4(ap)
          st   temp,0(5)
          .rtn

*         call ioa$ioars (temp_area,op1,op2)  op1 is a string, op2 is number
*         then copy temp area into op3

     instruction    insert_ioa
          save
          la   temp,io_buffer(sp)       temporary buffer
          st   temp,arg1p(sp)
          li   temp,x'54000050'         char(80) varying
          st   temp,dscrs+8
          l    source,op1(ops)
          bal  link,get_length
          sth  rv,dscrs+6               build up pl/1 type descriptors
          lhi  rv,x'1400'
          sth  rv,dscrs+4
          lis  index,0
          bal  link,get_init
          ar   text_ptr,index
          st   text_ptr,arg2p(sp)
          la   temp,op2(ops)
          st   temp,arg3p(sp)
          li   temp,x'1100001f'         fixed bin(31)
          st   temp,dscrs
          lhi  temp,-16
          st   temp,alist_size(sp)
          save
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$ioars_nnl
          restore

          la   temp,io_buffer+2(sp)     make it look like a sine string
          st   temp,op1(ops)
          l    temp,op3(ops)
          st   temp,op2(ops)
          bal  link,insert
          b    popj

*         Store a value in a vbl or temp

     instruction    store
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   rv,0(t2)
          br   link

*         store a value in a vbl

     instruction    estore
          l    rv,op1(ops)              get value
          l    t1,op2(ops)              get vbl
          st   rv,variable.value(t1)
          br   link

*         Creator functions

     instruction    make_buffer
          save
          la   temp,code
          st   temp,arg1p(sp)

*    If this arg is null then a new segment is created else it is a ptr
*    to an already existing segment which the buffer should point to.

          lis  temp,0
          st   temp,segptr(sp)
          la   temp,segptr(sp)
          st   temp,arg2p(sp)
          lhi  temp,12
          st   temp,alist_size(sp)
          la   ap,alist(sp)
          bal  link,$pl1_make_buffer
          restore
          l    rv,code
          br   link

     instruction    make_string
          save
          l    source,op1(ops)
          bal  link,get_length
          lr   5,rv
          ais  5,2                           for length field
          lr   t1,rv
          bal  link,allocate
          oi   rv,string_bits
          sth  t1,string.length(rv)
          l    source,op1(ops)
          lis  index,0
          bal  link,get_init
          la   t1,string.text(rv)
makstr.loop    equ  *
          balr link,get
          b    popj
          stb  char,0(t1)
          ais  t1,1
          bs   makstr.loop

     instruction    intern
          save
          l    source,op1(ops)
          lr   temp,source
          srl  temp,28
          clhi temp,string_type
          bes  int.OK
          bal  link,make_string
          st   rv,op1(ops)
          lr   source,rv

int.OK    lh   t1,string.length(source)
          lr   t2,t1
int.hash  sis  t1,1
          bms  int.got_hash
          lb   char,string.text(source,t1)
          ar   t2,char
          bs   int.hash
int.got_hash   equ  *
          l    t3,op2(ops)                   get array
          dh   t2,array.size+2(t3)           mod array size
          slls t2,2                          full word entries
          l    rv,array.cells(t2,t3)
          l    t5,op1(ops)                   get string we're looking for
          bz   int.new
int.look_loop  equ  *
          l    t4,variable.name(rv)
          lh   t1,string.length(t4)
          ch   t1,string.length(t5)          are the lengths the same
          bnes int.next
int.comp_loop  equ  *
          sis  t1,1
          bm   popj                          we found it
          lb   char,string.text(t4,t1)
          clb  char,string.text(t5,t1)
          bes  int.comp_loop

int.next  l    rv,variable.next(rv)          check next vbl in chain
          bnz  int.look_loop

int.new   lhi  5,variable_size
          bal  link,allocate
          oi   rv,variable_bits
          l    temp,array.cells(t2,t3)
          st   temp,variable.next(rv)
          st   rv,array.cells(t2,t3)
          l    temp,op1(ops)
          st   temp,variable.name(rv)
          lis  temp,0
          st   temp,variable.value(rv)
          b    popj

     instruction    make_window
          save
          lhi  5,window_size
          bal  link,allocate
          oi   rv,window_bits
          lr   t2,rv                         set mark doesn't bash this
          l    source,op1(ops)
          st   source,window.real_text(t2)
          bal  link,make_mark
          st   rv,window.start(t2)
          st   rv,op1(ops)
          st   source,op2(ops)
          lis  temp,0
          st   temp,op3(ops)
          bal  link,set_mark                      To thread them on the buffer
          bal  link,make_mark
          st   rv,window.stop(t2)
          st   rv,op1(ops)
          bal  link,set_mark
          lr   rv,t2
          b    popj

     instruction    define_window
          lis  temp,0
          st   temp,error_register
          lr   t2,link
          l    t1,op1(ops)
          l    source,window.real_text(t1)        get the buffer...
          l    index,op2(ops)
          l    rv,window.start(t1)
          bal  link,sm.gone                  do the set mark
          l    index,op3(ops)
          l    rv,window.stop(t1)
          bal  link,sm.gone                  do the set mark
          lr   rv,t1                         return the defined window
          br   t2                            return

     instruction    make_gnirt
          lr   t1,link
          lhi  5,gnirt_size+16
          bal  link,allocate
          oi   rv,gnirt_bits
          lis  temp,0
          sth  temp,gnirt.real_length(rv)
          lhi  temp,16
          sth  temp,gnirt.max_length(rv)
          la   temp,gnirt_size(rv)           get text ptr
          st   temp,gnirt.text_ptr(rv)
          br   t1

     instruction    make_mark
          save
          lis  5,marker_size
          bal  link,allocate
          oi   rv,marker_bits
          lis  temp,0
          st   temp,0(rv)
          st   temp,4(rv)
          b    popj

     instruction    make_variable
          save
          lcs  temp,1 0                     error means found it (not new)
          st   temp,error_register
          l    source,op1(ops)               Get name of vbl
          lr   temp,source
          srl  temp,28
          clhi temp,string_type
          bes  mv.got_string
          bal  link,make_string
          lr   source,rv
          st   rv,op1(ops)
mv.got_string  equ  *
          l    rv,linel_ptr                  get first vbl in chain
          bz   mv.new
mv.check_this  equ  *
          l    t1,variable.name(rv)
          lh   t3,string.length(t1)
          clh  t3,string.length(source)
          bne  mv.get_next
mv.comp   sis  t3,1
          bm   popj                          We have found a match
          lb   char,string.text(t1,t3)
          clb  char,string.text(source,t3)
          bnes mv.get_next
          bs   mv.comp
mv.get_next    equ  *
          l    rv,variable.next(rv)
          bnz  mv.check_this

mv.new    lr   temp,source
          srl  temp,28
          clhi temp,string_type
          bes  mv.no_copy_name
          bal  link,make_string              copy string into safe place
          lr   source,rv
mv.no_copy_name     equ  *
          lis  5,variable_size
          bal  link,allocate
          oi   rv,variable_bits
          l    t1,linel_ptr
          l    temp,variable.next(t1)        thread it on
          st   rv,variable.next(t1)
          st   temp,variable.next(rv)
          st   source,variable.name(rv)
          lis  temp,0
          st   temp,variable.value(rv)
          st   temp,error_register
          b    popj

     instruction    make_array
          save
          l    t1,op1(ops)                   get type of array.
          clhi t1,1                          bit array
          bes  ma.bits
          clhi t1,32
          bes  ma.full
          bal  link,error
error13   equ  *                             bad array cell size

ma.bits   l    5,op2(ops)                    # of bits
          sis  5,1                           round up
          ohi  5,x'1f'
          ais  5,1
          srls 5,3                           # of full bytes to allocate
          lr   t2,5
          srls t2,2                          # of full_words to zero
          bs   ma.alloc

ma.full   l    5,op2(ops)
          slls 5,2                           # of full word is op2
          l    t2,op1(ops)                   # of full words to zero

ma.alloc  ahi  5,array_size
          bal  link,allocate
          oi   rv,array_bits
          l    temp,op2(ops)
          st   temp,array.size(rv)
          l    t1,op1(ops)                   bits / cell
          st   t1,array.type(rv)
          lis  t1,0                          blast them out
          lr   t3,rv
ma.loop   sis  t2,1                          initialize
          bm   popj
          st   t1,array.cells(t3)
          ais  t3,4
          bs   ma.loop

*         Generalized text mover.

     instruction    insert_region
          save
          lis  temp,0
          st   temp,error_register
          l    source,op1(ops)
          bal  link,get_length          gets length of op1 (source)
          lr   len,rv
          bz   popj                     nothing to do...

          l    temp,op3(ops)
          bnms in.not_minus
          lr   temp,len
in.not_minus   equ  *
          s    temp,op2(ops)
          lr   len,temp
          bm   get_error

          l    temp,op2(ops)
          st   temp,insert.start
          lr   temp,source
          srl  temp,28
          clhi temp,buffer_type
          bes  in.hack_stop
          l    temp,op3(ops)
          st   temp,insert.stop
          bs   in.check_sink

in.hack_stop   equ  *
          l    temp,op3(ops)
          make_absolute_bufptr     temp,source
          st   temp,insert.stop

in.check_sink  equ  *
          l    sink,op4(ops)
          lr   temp,sink
          srl  temp,28
          clhi temp,buffer_type
          be   in.into_buffer

*    Inserting into a gnirt is easy just make sure it is big enough to
*    hold the new text then add it too the end.

          lh   5,gnirt.real_length(sink)
          ar   5,len                    add in new stuff
          clh  5,gnirt.max_length(sink)
          bnp  in.doit                  already big enough
          ohi  5,x'000f'                give some room to grow
          ais  5,1
          bal  link,allocate
          l    t2,gnirt.text_ptr(sink)
          lis  type,0                        copy ptr
in.copy_gnirt_loop  equ  *
          l    temp,0(t2,type)               copy the old text
          st   temp,0(rv,type)
          ais  type,4
          clh  type,gnirt.real_length(sink)
          bls  in.copy_gnirt_loop

          lr   type,5                        save new max length
          lr   t2,rv                         save new text_ptr

          lh   5,gnirt.max_length(sink)      free old block
          l    rv,gnirt.text_ptr(sink)
          bal  link,free

          sth  type,gnirt.max_length(sink)   set up the new values
          st   t2,gnirt.text_ptr(sink)

in.doit   l    index,insert.start
          bal  link,get_init
          l    type,insert.stop
          bnms in.default_stop
          l    type,get.stop
in.default_stop     equ  *
          l    put_ptr,gnirt.text_ptr(sink)
          ah   put_ptr,gnirt.real_length(sink)    always append to a gnirt
          ahm  len,gnirt.real_length(sink)
          lr   rv,sink                       return thing inserted into.
in.add_to_gnirt_loop     equ  *
          clr  index,type
          bnl  popj
          balr link,get
          b    popj
          stb  char,0(put_ptr)
          ais  put_ptr,1
          bs   in.add_to_gnirt_loop

in.into_buffer equ  *
          bal  link,update_gap          make sure everything is kool
          lis  temp,buffer.flags.wired
          sbt  temp,buffer.flags(sink)

*         t2 is also put_ptr which is OK to bash

          l    t2,buffer.start_mod(sink)
          bz   ins.no_mod_m             no marks to hassle with
          l    temp,buffer.location(sink)
          cl   temp,marker.mv(t2)
          bnls ins.check_em             start is before us: punt
          st   temp,marker.mv(t2)
ins.check_em   l    t2,buffer.end_mod(sink)
          bzs  ins.no_mod_m             just in case
          cl   temp,marker.mv(t2)
          bls  ins.no_mod_m
          l    temp,buffer.gap_end(sink) This is a marker value(point)
          st   temp,marker.mv(t2)

ins.no_mod_m   equ  *
          l    index,insert.start
          bal  link,get_init
          l    temp,insert.stop
          bms  in.default_stop1
          st   temp,get.stop
in.default_stop1    equ  *
          l    put_ptr,text_ptr(sink)
          a    put_ptr,buffer.location(sink)
          am   len,buffer.location(sink)
          am   len,gap_start(sink)
          lr   rv,sink

          lis  temp,buffer.flags.wired
          rbt  temp,buffer.flags(sink)

insert.loop    equ  *
          balr link,get
          b    popj
          stb  char,0(put_ptr)
          ais  put_ptr,1
          bs   insert.loop

     instruction    insert
          l    temp,op2(ops)
          st   temp,op4(ops)
          lis  temp,0
          st   temp,op2(ops)
          lcs  temp,1
          st   temp,op3(ops)            negative max means go to end
          b    insert_region

     instruction    nth
          lis  temp,0
          st   temp,error_register
          lr   t1,link
          l    source,op1(ops)
          l    index,op2(ops)
          bm   nth.error.low
          bal  link,get_length
          cr   index,rv
          bnm  nth.error.high
nth.restart    equ  *
          bal  link,get_init
          balr link,get
          b    nth.error
          lr   rv,char
          br   t1
nth.error lcs  rv,1
          st   rv,error_register
          br   t1
nth.error.low  equ  *
          lis  index,0
nth.error.common    equ  *
          lcs  rv,1
          st   rv,error_register
          b    nth.restart
nth.error.high equ  *
          lr   index,rv
          b    nth.error.common

     instruction    nthr
          l    source,op1(ops)
          l    temp,buffer.location(source)
          a    temp,op2(ops)
          st   temp,op2(ops)
          b    nth

     instruction    location
          l    source,op1(ops)
          l    rv,buffer.location(source)
          br   link

*         This gets the length of a text_object in source

     instruction    length
          l    source,op1(ops)
get_length     lr   type,source
          srl  type,28
          clhi type,0                   is it a number?
          bnes l.try_string
          cli  source,!2
          bps  l.is_string
          lis  rv,1
          br   link

l.try_string   clhi type,string_type
          bnes l.try_window
l.is_string    lhl  rv,string.length(source)
          br link

l.try_window   clhi type,window_type
          bne  l.try_buffer
          l    type,window.real_text(source)
          l    rv,window.stop(source)
          l    temp,marker.mv(rv)
          make_virtual_bufptr temp,type
          l    rv,window.start(source)
          l    rv,marker.mv(rv)
          make_virtual_bufptr rv,type
          sr   temp,rv
          lr   rv,temp
          br   link

l.try_buffer   clhi type,buffer_type
          bne  l.try_gnirt
          l    rv,buffer.gap_start(source)
          a    rv,buffer.top(source)
          s    rv,buffer.gap_end(source)
          br   link

l.try_gnirt    clhi type,gnirt_type
          bne  error4_do
          lh   rv,gnirt.real_length(source)
          br   link

     instruction    set_loc
          l    source,op1(ops)
          l    t2,op2(ops)              get new location
validate_loc   equ  *
          lis  temp,0
          st   temp,error_register
          lr   t2,t2               can't be negative
          bms  loc.error_less
          lr   t1,link
          bal  link,get_length
          lr   link,t1
          clr  t2,rv                    can't go pass the max
          bp   loc.error_more
          lr   rv,t2                    so we can return new location
          st   rv,buffer.location(source)
          br   link

loc.error_less equ  *
          lis  rv,0
          st   rv,buffer.location(source)
          bs   loc.error

loc.error_more equ  *                   set to length
          st   rv,buffer.location(source)

loc.error lcs  temp,1
          st   temp,error_register
          br   link
error5    equ  *

     instruction    add_to_loc
          l    source,op1(ops)
          l    t2,op2(ops)
          a    t2,buffer.location(source)
          b    validate_loc

*         deletes text from point to point + N

     instruction    delete
          lis  temp,0
          st   temp,error_register
          save
          l    source,op1(ops)
          lr   temp,source
          srl  temp,28
          clhi temp,buffer_type
          be   delete.from_buffer

          lis  temp,0                             Its a gnirt
          s    temp,op2(ops)
          bnm  popj
          ahm  temp,gnirt.real_length(source)
          bnm  popj                               all done
          lis  temp,0
          sth  temp,gnirt.real_length(source)     we deleted too far
get_error equ  *
          lcs  temp,1
          st   temp,error_register
          b    popj

delete.from_buffer  equ  *
          l    t1,buffer.location(source)
          l    index,op2(ops)
          bz   popj
          bms  delete.doit
          am   index,buffer.location(source)
          lr   temp,index
          lis  index,0
          sr   index,temp
delete.doit    lr   temp,index
          a    temp,buffer.location(source)
          bnms delete.enough

delete.too_big equ  *
          st   t1,buffer.location(source)    reset things
          b    get_error

error8         equ  *                        trying to delete too much

delete.enough  bal  link,get_length
          cl   rv,buffer.location(source)
          bls  delete.too_big
          lr   sink,source
          lis  len,0                    how big to make gap
          bal  link,update_gap
          l    temp,gap_start(source)
          lr   t2,temp                  save for later
          ar   temp,index               mung all markers here to gap
          l    t1,marker_chain(source)
          bzs  delete.finish
delete.floop   cl   temp,marker.mv(t1)       find the first marker to mung
          bnls delete.next_m            not this mark
          cl   t2,marker.mv(t1)
          bls  delete.next_m            not this either.
          st   temp,marker.mv(t1)       if in area to be deleted: pin it 
delete.next_m  l    t1,marker.next(t1)
          bnzs delete.floop
          bs   delete.finish

delete.finish  am   index,buffer.location(source) do the deletion
          am   index,gap_start(source)

          l    t2,buffer.start_mod(source)
          bz   popj                     not marks to hassle with
          l    temp,buffer.location(source)
          cl   temp,marker.mv(t2)
          bnls del.check_em             start is before us: punt
          st   temp,marker.mv(t2)
del.check_em   l    t2,buffer.end_mod(source)
          bz   popj                     just in case
          cl   temp,marker.mv(t2)
          bnp  popj
          st   temp,marker.mv(t2)

          b    popj

*         set_mark a,b,c Set the mark a in buffer b to the value c

     instruction    set_mark
          lis  temp,0
          st   temp,error_register
          l    source,op2(ops)
          l    rv,op1(ops)              make sure mark isn't on list
          l    index,op3(ops)
set_mark_reg   l    t1,marker_chain(source)
          bzs  sm.thread
sm.rem_loop    clr  rv,t1                    find mark if exists
          bes  sm.gone
          l    t1,marker.next(t1)
          bnzs sm.rem_loop
sm.thread l    t1,marker_chain(source)  If not found then thread it on
          st   t1,marker.next(rv)
          st   rv,marker_chain(source)

*    define_window calls in here.
sm.gone   make_absolute_bufptr     index,source
          cl   index,buffer.top(source)
          bnps sm.point_ok
          lcs  index,1
          st   index,error_register
          l    index,buffer.top(source)
sm.point_ok    equ  *
          st   index,marker.mv(rv)
          br   link

     instruction    unset_mark
          l    source,op2(ops)
          l    rv,op1(ops)
unset_mark_reg equ  *
          la   t1,marker_chain-marker.next(source)
usm.loop  cl   rv,marker.next(t1)
          bes  usm.unthread
          l    t1,marker.next(t1)
          bnzs usm.loop
          bal  link,error
error7    equ  *                        no such mark

usm.unthread   equ  *
          l    temp,marker.next(rv)
          st   temp,marker.next(t1)
          br   link

     instruction    eval_mark
          l    t1,op1(ops)
          l    source,op2(ops)
eval_mark_reg  equ  *
          l    rv,marker.mv(t1)
          make_virtual_bufptr rv,source
          br   link

     instruction    fill_vbl_array
          l    temp,op2(ops)            get number of cases
          l    t1,state.pc.loc
          l    t4,state.pc.buf
          l    t4,buffer.base(t4)
          l    t2,op1(ops)              get array
fva.loop  lhl  t3,0(t1,t4)              get function descriptor
          lr   rv,t3
          nhi  t3,x'6000'               get base register number
          srls t3,11                    shift it over.
          clhi t3,ip_reg_number         is it a vbl?
          bes  fva.vbl
          bal  link,error
error10   equ  *                        case not vbl

fva.vbl   nhi  rv,x'1fff'               get the offset
          sll  rv,19                    extend the sign
          sra  rv,17
          a    rv,state.ip              get address
          l    rv,0(rv)                 indirect through vbl_tab
          st   rv,array.cells(t2)
          ais  t2,4
          ais  t1,2
          sis  temp,1
          bp   fva.loop
          st   t1,state.pc.loc
          br   link

     instruction    fill_char_array
          save
          l    t1,op1(ops)                   get array to fill.
          l    temp,array.type(t1)           get type of array. must be bits
          clhi temp,1
          bes  fca.check_size
          bal  link,error
error9    equ  *

fca.check_size equ  *
          l    temp,array.size(t1)           must be 128 bits long
          clhi temp,128
          bnls fca.OK
          bal  link,error
error11   equ  *

fca.OK    l    source,op2(ops)               get string to get chars from
          lis  index,0
          bal  link,get_init
          lr   rv,t1                         return array
fca.loop  balr link,get
          b    popj
          nhi  char,x'7f'
          sbt  char,array.cells(t1)
          bs   fca.loop

     instruction    ar
          l    t1,op1(ops)              get array
          l    t2,op2(ops)              get index
          l    temp,array.type(t1)      bit array?
          clhi temp,1
          be   ar.bits

          slls t2,2
          l    rv,array.cells(t1,t2)
          br   link

ar.bits   lis  rv,0
          tbt  t2,array.cells(t1)       test the bit
          bzr  link
          lis  rv,1
          br   link

     instruction    as
          l    rv,op1(ops)              get value
          l    t1,op2(ops)
          l    t2,op3(ops)
          l    temp,array.type(t1)      bit array?
          clhi temp,1
          be   as.bits

          slls t2,2
          st   rv,array.cells(t1,t2)
          br   link

as.bits   lr   rv,rv
          bzs  as.zero_bit
          sbt  t2,array.cells(t1)
          br   link
as.zero_bit    equ  *
          rbt  t2,array.cells(t1)
          br   link

     instruction    copy_array
          lr   t3,link
          l    t1,op1(ops)
          l    t2,op2(ops)
          bnzs ca.got
          l    temp,array.type(t1)
          st   temp,op1(ops)
          l    temp,array.size(t1)
          st   temp,op2(ops)
          bal  link,make_array
          lr   t2,rv
          bs   ca.dont_check

do_error16     equ  *
          bal  link,error
error16   equ  *

ca.got    l    temp,array.type(t1)
          cl   temp,array.type(t2)
          bnes do_error16
          l    temp,array.size(t1)
          cl   temp,array.size(t2)
          bnes do_error16

ca.dont_check  equ  *
          l    t4,array.size(t1)
          mh   t4,array.type+2(t1)           total number of bits
          sis  t4,1
          ohi  t4,x'001f'
          ais  t4,1
          srls t4,3                          bytes
          lr   rv,t2
ca.loop   sis  t4,4
          bmr  t3
          l    temp,array.cells(t1,t4)
          st   temp,array.cells(t2,t4)
          bs   ca.loop

     instruction    make_screen
          b    $real_make_screen

     instruction    display
          b    $real_display

     instruction    force_display
          b    $real_force_display

     instruction    display_screen
          b    $real_display_screen

     instruction    get_hpos
          b    $real_get_hpos

*         Token handling instructions with flexibility

     instruction    find_first_in_fa
          lis  t1,1           forward
          lis  t2,1           absolute
          b    ffi.common

     instruction    find_first_in_fr
          lis  t1,1
          lis  t2,0
          b    ffi.common

     instruction    find_first_in_ba
          lcs  t1,1
          lis  t2,1
          b    ffi.common

     instruction    find_first_in_br
          lcs  t1,1
          lis  t2,0
          b    ffi.common

     instruction    find_first_not_in_fa
          lis  t1,1           forward
          lis  t2,1           absolute
          b    ffni.common

     instruction    find_first_not_in_fr
          lis  t1,1
          lis  t2,0
          b    ffni.common

     instruction    find_first_not_in_ba
          lcs  t1,1
          lis  t2,1
          b    ffni.common

     instruction    find_first_not_in_br
          lcs  t1,1
          lis  t2,0
          b    ffni.common

ffi.common     equ  *
          save
          lis  temp,0
          st   temp,error_register
          l    t3,op2(ops)                        get bit map
          bal  link,ff.string
          l    source,op1(ops)                    get buffer to look through
          l    rv,buffer.location(source)
          l    index,buffer.location(source)
          lr   t1,t1
          bms  ffi.reverse
          bal  link,get_init
          bs   ffi.start
ffi.reverse    equ  *
          bal  link,getr_init

ffi.start balr link,get
          b    ffi.error                          none found
          tbt  char,array.cells(t3)
          bzs  ffi.start                          not found: loop
ffi.done  make_virtual_bufptr index,source
          lr   rv,index
          sr   rv,t1                              back up one
          lr   t1,t1
          bps  ffi.return
          ais  rv,1
ffi.return     equ  *
          lr   t2,t2
          bnz  popj
          s    rv,buffer.location(source)
          b    popj

ffi.error equ  *
          lcs  temp,1
          st   temp,error_register
          bs   ffi.return

ffni.common    equ  *
          save
          lis  temp,0
          st   temp,error_register
          l    t3,op2(ops)                        get bit map
          bal  link,ff.string
          l    source,op1(ops)                    get buffer to look through
          l    rv,buffer.location(source)
          l    index,buffer.location(source)
          lr   t1,t1
          bms  ffni.reverse
          bal  link,get_init
          bs   ffni.start
ffni.reverse   equ  *
          bal  link,getr_init

ffni.start     equ  *
          balr link,get
          b    ffi.error                     none found
          tbt  char,array.cells(t3)
          bnzs ffni.start                         found one: loop
          b    ffi.done

ff.string equ  *
          lr   temp,t3
          srl  temp,28
          clhi temp,array_type
          ber  link                          alreay kool
          lis  temp,0
          st   temp,bit_map.cells(sp)
          st   temp,bit_map.cells+4(sp)
          st   temp,bit_map.cells+8(sp)
          st   temp,bit_map.cells+12(sp)
          la   t3,bit_map.t(sp)
          oi   t3,array_bits
          l    source,op2(ops)
          lis  index,0
          lr   rv,link
          bal  link,get_init
ff.loop   balr link,get
          br   rv
          dc   0
          sbt  char,bit_map.cells(sp)
          bs   ff.loop

*         Token handling instructions

     instruction    to_token_fa
          lis  t1,1           forward
          lis  t2,1           absolute
          b    ws.common

     instruction    to_token_ba
          lcs  t1,1           backward
          lis  t2,1           absolute
          b    ws.common

     instruction    to_token_fr
          lis  t1,1           forward
          lis  t2,0           relative
          b    ws.common

     instruction    to_token_br
          lcs  t1,1           backward
          lis  t2,0           relative

ws.common save
          l    source,op1(ops)          get the buffer
          l    index,buffer.location(source)

          lr   t1,t1
          bms  ws.use_getr              use the proper init routine
          bal  link,get_init
          bs   ws.loop
ws.use_getr    equ  *
          bal  link,getr_init

ws.loop   balr link,get
          b    ws.off_end               don't move if off the end
          tbt  char,break_table
          bnzs ws.loop

          make_virtual_bufptr index,source
          lr   rv,index
          sr   rv,t1
          lr   t1,t1
          bps  ws.not_back
          ais  rv,1
ws.not_back    equ  *
          lr   t2,t2
          bnz  popj                     return it as is
          s    rv,buffer.location(source)    make it relative to point
          b    popj
ws.off_end     equ  *
          lr   rv,t2                    relative (return zero)
          bz   popj
          l    rv,buffer.location(source)
          b    popj

*         Now the token stuff

     instruction    over_token_fa
          lis  t1,1           forward
          lis  t2,1           absolute
          b    tok.common

     instruction    over_token_ba
          lcs  t1,1           backward
          lis  t2,1           absolute
          b    tok.common

     instruction    over_token_fr
          lis  t1,1           forward
          lis  t2,0           relative
          b    tok.common

     instruction    over_token_br
          lcs  t1,1           backward
          lis  t2,0           relative

tok.common     save
          l    source,op1(ops)          get the buffer
          l    index,buffer.location(source)

          lr   t1,t1
          bms  tok.use_getr             use the proper init routine
          bal  link,get_init
          bs   tok.skip_white_space
tok.use_getr   equ  *
          bal  link,getr_init

tok.skip_white_space     equ  *
          balr link,get
          b    ws.off_end
          tbt  char,break_table
          bnzs tok.skip_white_space

*    now get to end of token

tok.find_token_end  equ  *
          balr link,get
          b    tok.off_end
          tbt  char,break_table
          bzs  tok.find_token_end

tok.off_end    equ  *                        just remember not to sis one
          make_virtual_bufptr index,source
          lr   char,char
          bms  tok.no_sis

          sr   index,t1                      point at first white space
          lr   t1,t1
          bps  tok.no_sis
          ais  index,1
tok.no_sis     equ  *
          lr   rv,index
          lr   t2,t2                         relative or absolute
          bnz  popj
          s    rv,buffer.location(source)
          b    popj

break_table    equ  *
* dcl break_data bit(128) static init("007c0000e3ff003e0000001e0000001c"b4);
          dc   x'007c',x'0000',x'e3ff',x'003e'
          dc   x'0000',x'001e',x'0000',x'001c'

     instruction    get_pname
          l    t1,op1(ops)
          l    rv,variable.name(t1)
          br   link

     instruction    command_args
    "     l    t1,76(sp)                     get saved register 15
          l    t2,op1(ops)                   which arg does she want
          slls t2,2
          ais  t2,4
          lis  rv,0
          cl   t2,0(t1)                      too many?
          bnlr link
          l    t3,0(t1,t2)
          l    rv,0(t3)
          br   link

     instruction    make_read_only
          l    rv,op1(ops)
          lis  temp,buffer.flags.read_only
          sbt  temp,buffer.flags(rv)
          br   link

     instruction    get_documentation
          lis  temp,0
          st   temp,error_register
          l    t1,op1(ops)
          l    t2,variable.value(t1)
          lr   temp,t2
          srl  temp,28
          clhi temp,function_type
          bnes get_error_np
          l    t1,function.vbl_tab(t2)
          lh   t2,0(t1)       get statics number
          l    rv,4(t1,t2)
          br   link
get_error_np   equ  *
          lcs  temp,1
          st   temp,error_register
          br   link

^L